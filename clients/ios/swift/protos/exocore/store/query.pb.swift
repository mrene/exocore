// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: exocore/store/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Exocore_Store_EntityResultSource: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case pending // = 1
  case chain // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .pending
    case 2: self = .chain
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .pending: return 1
    case .chain: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Exocore_Store_EntityResultSource: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Exocore_Store_EntityResultSource] = [
    .unknown,
    .pending,
    .chain,
  ]
}

#endif  // swift(>=4.2)

public struct Exocore_Store_EntityQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var predicate: Exocore_Store_EntityQuery.OneOf_Predicate? = nil

  public var match: Exocore_Store_MatchPredicate {
    get {
      if case .match(let v)? = predicate {return v}
      return Exocore_Store_MatchPredicate()
    }
    set {predicate = .match(newValue)}
  }

  public var trait: Exocore_Store_TraitPredicate {
    get {
      if case .trait(let v)? = predicate {return v}
      return Exocore_Store_TraitPredicate()
    }
    set {predicate = .trait(newValue)}
  }

  public var ids: Exocore_Store_IdsPredicate {
    get {
      if case .ids(let v)? = predicate {return v}
      return Exocore_Store_IdsPredicate()
    }
    set {predicate = .ids(newValue)}
  }

  public var reference: Exocore_Store_ReferencePredicate {
    get {
      if case .reference(let v)? = predicate {return v}
      return Exocore_Store_ReferencePredicate()
    }
    set {predicate = .reference(newValue)}
  }

  public var operations: Exocore_Store_OperationsPredicate {
    get {
      if case .operations(let v)? = predicate {return v}
      return Exocore_Store_OperationsPredicate()
    }
    set {predicate = .operations(newValue)}
  }

  public var all: Exocore_Store_AllPredicate {
    get {
      if case .all(let v)? = predicate {return v}
      return Exocore_Store_AllPredicate()
    }
    set {predicate = .all(newValue)}
  }

  public var test: Exocore_Store_TestPredicate {
    get {
      if case .test(let v)? = predicate {return v}
      return Exocore_Store_TestPredicate()
    }
    set {predicate = .test(newValue)}
  }

  //// Optional projections on traits and fields to be returned.
  public var projections: [Exocore_Store_Projection] = []

  //// Query paging requested.
  public var paging: Exocore_Store_Paging {
    get {return _paging ?? Exocore_Store_Paging()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  //// Query ordering.
  public var ordering: Exocore_Store_Ordering {
    get {return _ordering ?? Exocore_Store_Ordering()}
    set {_ordering = newValue}
  }
  /// Returns true if `ordering` has been explicitly set.
  public var hasOrdering: Bool {return self._ordering != nil}
  /// Clears the value of `ordering`. Subsequent reads from it will return its default value.
  public mutating func clearOrdering() {self._ordering = nil}

  //// Optional watch token if this query is to be used for watching.
  public var watchToken: UInt64 = 0

  //// If specified, if results from server matches this hash, results will be empty with the 
  //// `skipped_hash` field set to `true`.
  public var resultHash: UInt64 = 0

  //// Include deleted mutations matches. Can be used to return recently modified entities that
  //// also include deletions. Deleted traits will be included in the results, but will have a 
  //// `deletion_date` field with the date of the deletion.
  public var includeDeleted: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Predicate: Equatable {
    case match(Exocore_Store_MatchPredicate)
    case trait(Exocore_Store_TraitPredicate)
    case ids(Exocore_Store_IdsPredicate)
    case reference(Exocore_Store_ReferencePredicate)
    case operations(Exocore_Store_OperationsPredicate)
    case all(Exocore_Store_AllPredicate)
    case test(Exocore_Store_TestPredicate)

  #if !swift(>=4.1)
    public static func ==(lhs: Exocore_Store_EntityQuery.OneOf_Predicate, rhs: Exocore_Store_EntityQuery.OneOf_Predicate) -> Bool {
      switch (lhs, rhs) {
      case (.match(let l), .match(let r)): return l == r
      case (.trait(let l), .trait(let r)): return l == r
      case (.ids(let l), .ids(let r)): return l == r
      case (.reference(let l), .reference(let r)): return l == r
      case (.operations(let l), .operations(let r)): return l == r
      case (.all(let l), .all(let r)): return l == r
      case (.test(let l), .test(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _paging: Exocore_Store_Paging? = nil
  fileprivate var _ordering: Exocore_Store_Ordering? = nil
}

public struct Exocore_Store_Projection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// If specified, a prefix match will be done against traits' Protobuf full name (`some.package.Name`).
  //// If ends with a dollar sign "$", an exact match is required (ex: `some.package.Name$` will only match this message)
  public var package: [String] = []

  //// Skips the trait if the projection matches.
  public var skip: Bool = false

  //// If specified, only return these fields.
  public var fieldIds: [UInt32] = []

  //// If specified, only return fields annotated with `options.proto`.`field_group_id` matching ids.
  public var fieldGroupIds: [UInt32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Query entities by text match on all indexed fields across all traits.
public struct Exocore_Store_MatchPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var query: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Query entities by IDs.
public struct Exocore_Store_IdsPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Query entities by mutations' operation ids.
//// Used to return entities on which mutations with these operation ids were applied and indexed.
public struct Exocore_Store_OperationsPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var operationIds: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Query all entities.
public struct Exocore_Store_AllPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Used for tests.
public struct Exocore_Store_TestPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Query entities that have a specified trait and optionally matching a trait query.
public struct Exocore_Store_TraitPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var traitName: String = String()

  public var query: Exocore_Store_TraitQuery {
    get {return _query ?? Exocore_Store_TraitQuery()}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {self._query = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _query: Exocore_Store_TraitQuery? = nil
}

public struct Exocore_Store_TraitQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var predicate: Exocore_Store_TraitQuery.OneOf_Predicate? = nil

  public var match: Exocore_Store_MatchPredicate {
    get {
      if case .match(let v)? = predicate {return v}
      return Exocore_Store_MatchPredicate()
    }
    set {predicate = .match(newValue)}
  }

  public var field: Exocore_Store_TraitFieldPredicate {
    get {
      if case .field(let v)? = predicate {return v}
      return Exocore_Store_TraitFieldPredicate()
    }
    set {predicate = .field(newValue)}
  }

  public var reference: Exocore_Store_TraitFieldReferencePredicate {
    get {
      if case .reference(let v)? = predicate {return v}
      return Exocore_Store_TraitFieldReferencePredicate()
    }
    set {predicate = .reference(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Predicate: Equatable {
    case match(Exocore_Store_MatchPredicate)
    case field(Exocore_Store_TraitFieldPredicate)
    case reference(Exocore_Store_TraitFieldReferencePredicate)

  #if !swift(>=4.1)
    public static func ==(lhs: Exocore_Store_TraitQuery.OneOf_Predicate, rhs: Exocore_Store_TraitQuery.OneOf_Predicate) -> Bool {
      switch (lhs, rhs) {
      case (.match(let l), .match(let r)): return l == r
      case (.field(let l), .field(let r)): return l == r
      case (.reference(let l), .reference(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Exocore_Store_TraitFieldPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: String = String()

  public var value: Exocore_Store_TraitFieldPredicate.OneOf_Value? = nil

  public var string: String {
    get {
      if case .string(let v)? = value {return v}
      return String()
    }
    set {value = .string(newValue)}
  }

  public var int64: Int64 {
    get {
      if case .int64(let v)? = value {return v}
      return 0
    }
    set {value = .int64(newValue)}
  }

  public var uint64: UInt64 {
    get {
      if case .uint64(let v)? = value {return v}
      return 0
    }
    set {value = .uint64(newValue)}
  }

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .date(let v)? = value {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {value = .date(newValue)}
  }

  public var `operator`: Exocore_Store_TraitFieldPredicate.Operator = .equal

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case string(String)
    case int64(Int64)
    case uint64(UInt64)
    case date(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Exocore_Store_TraitFieldPredicate.OneOf_Value, rhs: Exocore_Store_TraitFieldPredicate.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.string(let l), .string(let r)): return l == r
      case (.int64(let l), .int64(let r)): return l == r
      case (.uint64(let l), .uint64(let r)): return l == r
      case (.date(let l), .date(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum Operator: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case equal // = 0
    case gt // = 1
    case gte // = 2
    case lt // = 3
    case lte // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .equal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .equal
      case 1: self = .gt
      case 2: self = .gte
      case 3: self = .lt
      case 4: self = .lte
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .equal: return 0
      case .gt: return 1
      case .gte: return 2
      case .lt: return 3
      case .lte: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Exocore_Store_TraitFieldPredicate.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Exocore_Store_TraitFieldPredicate.Operator] = [
    .equal,
    .gt,
    .gte,
    .lt,
    .lte,
  ]
}

#endif  // swift(>=4.2)

public struct Exocore_Store_TraitFieldReferencePredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: String = String()

  public var reference: Exocore_Store_ReferencePredicate {
    get {return _reference ?? Exocore_Store_ReferencePredicate()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _reference: Exocore_Store_ReferencePredicate? = nil
}

public struct Exocore_Store_ReferencePredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Entity id the reference points to
  public var entityID: String = String()

  /// Optional trait id the reference points to
  public var traitID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Exocore_Store_Paging {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Returns results after this given ordering value.
  public var afterOrderingValue: Exocore_Store_OrderingValue {
    get {return _afterOrderingValue ?? Exocore_Store_OrderingValue()}
    set {_afterOrderingValue = newValue}
  }
  /// Returns true if `afterOrderingValue` has been explicitly set.
  public var hasAfterOrderingValue: Bool {return self._afterOrderingValue != nil}
  /// Clears the value of `afterOrderingValue`. Subsequent reads from it will return its default value.
  public mutating func clearAfterOrderingValue() {self._afterOrderingValue = nil}

  //// Returns results before this given ordering value.
  public var beforeOrderingValue: Exocore_Store_OrderingValue {
    get {return _beforeOrderingValue ?? Exocore_Store_OrderingValue()}
    set {_beforeOrderingValue = newValue}
  }
  /// Returns true if `beforeOrderingValue` has been explicitly set.
  public var hasBeforeOrderingValue: Bool {return self._beforeOrderingValue != nil}
  /// Clears the value of `beforeOrderingValue`. Subsequent reads from it will return its default value.
  public mutating func clearBeforeOrderingValue() {self._beforeOrderingValue = nil}

  //// Desired results count. Default if 0.
  public var count: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _afterOrderingValue: Exocore_Store_OrderingValue? = nil
  fileprivate var _beforeOrderingValue: Exocore_Store_OrderingValue? = nil
}

public struct Exocore_Store_Ordering {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Value by which we want results to be ordered.
  public var value: Exocore_Store_Ordering.OneOf_Value? = nil

  public var score: Bool {
    get {
      if case .score(let v)? = value {return v}
      return false
    }
    set {value = .score(newValue)}
  }

  public var operationID: Bool {
    get {
      if case .operationID(let v)? = value {return v}
      return false
    }
    set {value = .operationID(newValue)}
  }

  public var field: String {
    get {
      if case .field(let v)? = value {return v}
      return String()
    }
    set {value = .field(newValue)}
  }

  //// Direction of ordering.
  public var ascending: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// Value by which we want results to be ordered.
  public enum OneOf_Value: Equatable {
    case score(Bool)
    case operationID(Bool)
    case field(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Exocore_Store_Ordering.OneOf_Value, rhs: Exocore_Store_Ordering.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.score(let l), .score(let r)): return l == r
      case (.operationID(let l), .operationID(let r)): return l == r
      case (.field(let l), .field(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Exocore_Store_OrderingValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Primary comparison
  public var value: Exocore_Store_OrderingValue.OneOf_Value? = nil

  public var float: Float {
    get {
      if case .float(let v)? = value {return v}
      return 0
    }
    set {value = .float(newValue)}
  }

  public var uint64: UInt64 {
    get {
      if case .uint64(let v)? = value {return v}
      return 0
    }
    set {value = .uint64(newValue)}
  }

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .date(let v)? = value {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {value = .date(newValue)}
  }

  public var min: Bool {
    get {
      if case .min(let v)? = value {return v}
      return false
    }
    set {value = .min(newValue)}
  }

  public var max: Bool {
    get {
      if case .max(let v)? = value {return v}
      return false
    }
    set {value = .max(newValue)}
  }

  //// Secondary comparison, in case values were equal. In this case,
  //// the last operation id that mutated the entity is used.
  public var operationID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// Primary comparison
  public enum OneOf_Value: Equatable {
    case float(Float)
    case uint64(UInt64)
    case date(SwiftProtobuf.Google_Protobuf_Timestamp)
    case min(Bool)
    case max(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Exocore_Store_OrderingValue.OneOf_Value, rhs: Exocore_Store_OrderingValue.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.float(let l), .float(let r)): return l == r
      case (.uint64(let l), .uint64(let r)): return l == r
      case (.date(let l), .date(let r)): return l == r
      case (.min(let l), .min(let r)): return l == r
      case (.max(let l), .max(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Exocore_Store_EntityResults {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Entities matching query.
  public var entities: [Exocore_Store_EntityResult] = []

  //// If query specified a `result_hash`, this is set to `true` if the results
  //// had the same hash has the specified and that `entities` were set to empty.
  public var skippedHash: Bool = false

  //// Estimated number of entities matching, based on number of matching mutations.
  public var estimatedCount: UInt32 = 0

  //// Paging token of the current results.
  public var currentPage: Exocore_Store_Paging {
    get {return _currentPage ?? Exocore_Store_Paging()}
    set {_currentPage = newValue}
  }
  /// Returns true if `currentPage` has been explicitly set.
  public var hasCurrentPage: Bool {return self._currentPage != nil}
  /// Clears the value of `currentPage`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentPage() {self._currentPage = nil}

  //// Paging token of the next page of results.
  public var nextPage: Exocore_Store_Paging {
    get {return _nextPage ?? Exocore_Store_Paging()}
    set {_nextPage = newValue}
  }
  /// Returns true if `nextPage` has been explicitly set.
  public var hasNextPage: Bool {return self._nextPage != nil}
  /// Clears the value of `nextPage`. Subsequent reads from it will return its default value.
  public mutating func clearNextPage() {self._nextPage = nil}

  //// Hash of the results. Can be used to prevent receiving same results if they haven't
  //// changed by using the `result_hash` field on the query.
  public var hash: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _currentPage: Exocore_Store_Paging? = nil
  fileprivate var _nextPage: Exocore_Store_Paging? = nil
}

public struct Exocore_Store_EntityResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The entity with its traits. Projection could have been done on the entity, which will
  //// be indicated in its traits' details field.
  public var entity: Exocore_Store_Entity {
    get {return _entity ?? Exocore_Store_Entity()}
    set {_entity = newValue}
  }
  /// Returns true if `entity` has been explicitly set.
  public var hasEntity: Bool {return self._entity != nil}
  /// Clears the value of `entity`. Subsequent reads from it will return its default value.
  public mutating func clearEntity() {self._entity = nil}

  //// Indicates where the entity was taken from in terms of storage. If all of the entities'
  //// traits were coming from the chain (i.e. committed), the source will be `CHAIN`. Otherwise,
  //// as soon as one entity mutation is coming from pending store (i.e. not committed yet), this
  //// field will be `PENDING`.
  ////
  //// This can be used to know if an entity can be considered stable once mutations were executed on it.
  //// Once it's committed, a majority of nodes agreed on it and will not result in further changes happening
  //// before the latest consistent timestamp.
  public var source: Exocore_Store_EntityResultSource = .unknown

  //// Value to be used to order results. `EntityResults` already contains ordered results,
  //// but it may be useful to compare ordering queries (ex.: to merge different pages)
  public var orderingValue: Exocore_Store_OrderingValue {
    get {return _orderingValue ?? Exocore_Store_OrderingValue()}
    set {_orderingValue = newValue}
  }
  /// Returns true if `orderingValue` has been explicitly set.
  public var hasOrderingValue: Bool {return self._orderingValue != nil}
  /// Clears the value of `orderingValue`. Subsequent reads from it will return its default value.
  public mutating func clearOrderingValue() {self._orderingValue = nil}

  //// Hash of the tntiy result. Can be used to compare if the entity has changed since last results.
  public var hash: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _entity: Exocore_Store_Entity? = nil
  fileprivate var _orderingValue: Exocore_Store_OrderingValue? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "exocore.store"

extension Exocore_Store_EntityResultSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "CHAIN"),
  ]
}

extension Exocore_Store_EntityQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "match"),
    2: .same(proto: "trait"),
    3: .same(proto: "ids"),
    4: .same(proto: "reference"),
    10: .same(proto: "operations"),
    11: .same(proto: "all"),
    99: .same(proto: "test"),
    7: .same(proto: "projections"),
    5: .same(proto: "paging"),
    6: .same(proto: "ordering"),
    8: .standard(proto: "watch_token"),
    9: .standard(proto: "result_hash"),
    12: .standard(proto: "include_deleted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Exocore_Store_MatchPredicate?
        if let current = self.predicate {
          try decoder.handleConflictingOneOf()
          if case .match(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.predicate = .match(v)}
      case 2:
        var v: Exocore_Store_TraitPredicate?
        if let current = self.predicate {
          try decoder.handleConflictingOneOf()
          if case .trait(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.predicate = .trait(v)}
      case 3:
        var v: Exocore_Store_IdsPredicate?
        if let current = self.predicate {
          try decoder.handleConflictingOneOf()
          if case .ids(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.predicate = .ids(v)}
      case 4:
        var v: Exocore_Store_ReferencePredicate?
        if let current = self.predicate {
          try decoder.handleConflictingOneOf()
          if case .reference(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.predicate = .reference(v)}
      case 5: try decoder.decodeSingularMessageField(value: &self._paging)
      case 6: try decoder.decodeSingularMessageField(value: &self._ordering)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.projections)
      case 8: try decoder.decodeSingularUInt64Field(value: &self.watchToken)
      case 9: try decoder.decodeSingularUInt64Field(value: &self.resultHash)
      case 10:
        var v: Exocore_Store_OperationsPredicate?
        if let current = self.predicate {
          try decoder.handleConflictingOneOf()
          if case .operations(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.predicate = .operations(v)}
      case 11:
        var v: Exocore_Store_AllPredicate?
        if let current = self.predicate {
          try decoder.handleConflictingOneOf()
          if case .all(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.predicate = .all(v)}
      case 12: try decoder.decodeSingularBoolField(value: &self.includeDeleted)
      case 99:
        var v: Exocore_Store_TestPredicate?
        if let current = self.predicate {
          try decoder.handleConflictingOneOf()
          if case .test(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.predicate = .test(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.predicate {
    case .match(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .trait(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .ids(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .reference(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case nil: break
    default: break
    }
    if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._ordering {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.projections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.projections, fieldNumber: 7)
    }
    if self.watchToken != 0 {
      try visitor.visitSingularUInt64Field(value: self.watchToken, fieldNumber: 8)
    }
    if self.resultHash != 0 {
      try visitor.visitSingularUInt64Field(value: self.resultHash, fieldNumber: 9)
    }
    switch self.predicate {
    case .operations(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    case .all(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    case nil: break
    default: break
    }
    if self.includeDeleted != false {
      try visitor.visitSingularBoolField(value: self.includeDeleted, fieldNumber: 12)
    }
    if case .test(let v)? = self.predicate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_EntityQuery, rhs: Exocore_Store_EntityQuery) -> Bool {
    if lhs.predicate != rhs.predicate {return false}
    if lhs.projections != rhs.projections {return false}
    if lhs._paging != rhs._paging {return false}
    if lhs._ordering != rhs._ordering {return false}
    if lhs.watchToken != rhs.watchToken {return false}
    if lhs.resultHash != rhs.resultHash {return false}
    if lhs.includeDeleted != rhs.includeDeleted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_Projection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Projection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "package"),
    2: .same(proto: "skip"),
    4: .standard(proto: "field_ids"),
    5: .standard(proto: "field_group_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.package)
      case 2: try decoder.decodeSingularBoolField(value: &self.skip)
      case 4: try decoder.decodeRepeatedUInt32Field(value: &self.fieldIds)
      case 5: try decoder.decodeRepeatedUInt32Field(value: &self.fieldGroupIds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.package.isEmpty {
      try visitor.visitRepeatedStringField(value: self.package, fieldNumber: 1)
    }
    if self.skip != false {
      try visitor.visitSingularBoolField(value: self.skip, fieldNumber: 2)
    }
    if !self.fieldIds.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.fieldIds, fieldNumber: 4)
    }
    if !self.fieldGroupIds.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.fieldGroupIds, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_Projection, rhs: Exocore_Store_Projection) -> Bool {
    if lhs.package != rhs.package {return false}
    if lhs.skip != rhs.skip {return false}
    if lhs.fieldIds != rhs.fieldIds {return false}
    if lhs.fieldGroupIds != rhs.fieldGroupIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_MatchPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.query)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_MatchPredicate, rhs: Exocore_Store_MatchPredicate) -> Bool {
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_IdsPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdsPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.ids)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_IdsPredicate, rhs: Exocore_Store_IdsPredicate) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_OperationsPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationsPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "operation_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedUInt64Field(value: &self.operationIds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operationIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.operationIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_OperationsPredicate, rhs: Exocore_Store_OperationsPredicate) -> Bool {
    if lhs.operationIds != rhs.operationIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_AllPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AllPredicate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_AllPredicate, rhs: Exocore_Store_AllPredicate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_TestPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.success)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_TestPredicate, rhs: Exocore_Store_TestPredicate) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_TraitPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraitPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trait_name"),
    2: .same(proto: "query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.traitName)
      case 2: try decoder.decodeSingularMessageField(value: &self._query)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.traitName.isEmpty {
      try visitor.visitSingularStringField(value: self.traitName, fieldNumber: 1)
    }
    if let v = self._query {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_TraitPredicate, rhs: Exocore_Store_TraitPredicate) -> Bool {
    if lhs.traitName != rhs.traitName {return false}
    if lhs._query != rhs._query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_TraitQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraitQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "match"),
    2: .same(proto: "field"),
    3: .same(proto: "reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Exocore_Store_MatchPredicate?
        if let current = self.predicate {
          try decoder.handleConflictingOneOf()
          if case .match(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.predicate = .match(v)}
      case 2:
        var v: Exocore_Store_TraitFieldPredicate?
        if let current = self.predicate {
          try decoder.handleConflictingOneOf()
          if case .field(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.predicate = .field(v)}
      case 3:
        var v: Exocore_Store_TraitFieldReferencePredicate?
        if let current = self.predicate {
          try decoder.handleConflictingOneOf()
          if case .reference(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.predicate = .reference(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.predicate {
    case .match(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .field(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .reference(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_TraitQuery, rhs: Exocore_Store_TraitQuery) -> Bool {
    if lhs.predicate != rhs.predicate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_TraitFieldPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraitFieldPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "string"),
    3: .same(proto: "int64"),
    4: .same(proto: "uint64"),
    5: .same(proto: "date"),
    6: .same(proto: "operator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.field)
      case 2:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .string(v)}
      case 3:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.value = .int64(v)}
      case 4:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {self.value = .uint64(v)}
      case 5:
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .date(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .date(v)}
      case 6: try decoder.decodeSingularEnumField(value: &self.`operator`)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.field.isEmpty {
      try visitor.visitSingularStringField(value: self.field, fieldNumber: 1)
    }
    switch self.value {
    case .string(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case .int64(let v)?:
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    case .uint64(let v)?:
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    case .date(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case nil: break
    }
    if self.`operator` != .equal {
      try visitor.visitSingularEnumField(value: self.`operator`, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_TraitFieldPredicate, rhs: Exocore_Store_TraitFieldPredicate) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.value != rhs.value {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_TraitFieldPredicate.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EQUAL"),
    1: .same(proto: "GT"),
    2: .same(proto: "GTE"),
    3: .same(proto: "LT"),
    4: .same(proto: "LTE"),
  ]
}

extension Exocore_Store_TraitFieldReferencePredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraitFieldReferencePredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.field)
      case 2: try decoder.decodeSingularMessageField(value: &self._reference)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.field.isEmpty {
      try visitor.visitSingularStringField(value: self.field, fieldNumber: 1)
    }
    if let v = self._reference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_TraitFieldReferencePredicate, rhs: Exocore_Store_TraitFieldReferencePredicate) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_ReferencePredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReferencePredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
    2: .standard(proto: "trait_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.entityID)
      case 2: try decoder.decodeSingularStringField(value: &self.traitID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entityID.isEmpty {
      try visitor.visitSingularStringField(value: self.entityID, fieldNumber: 1)
    }
    if !self.traitID.isEmpty {
      try visitor.visitSingularStringField(value: self.traitID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_ReferencePredicate, rhs: Exocore_Store_ReferencePredicate) -> Bool {
    if lhs.entityID != rhs.entityID {return false}
    if lhs.traitID != rhs.traitID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_Paging: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Paging"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "after_ordering_value"),
    2: .standard(proto: "before_ordering_value"),
    3: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._afterOrderingValue)
      case 2: try decoder.decodeSingularMessageField(value: &self._beforeOrderingValue)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.count)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._afterOrderingValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._beforeOrderingValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt32Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_Paging, rhs: Exocore_Store_Paging) -> Bool {
    if lhs._afterOrderingValue != rhs._afterOrderingValue {return false}
    if lhs._beforeOrderingValue != rhs._beforeOrderingValue {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_Ordering: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ordering"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .standard(proto: "operation_id"),
    3: .same(proto: "field"),
    4: .same(proto: "ascending"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.value = .score(v)}
      case 2:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.value = .operationID(v)}
      case 3:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .field(v)}
      case 4: try decoder.decodeSingularBoolField(value: &self.ascending)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.value {
    case .score(let v)?:
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    case .operationID(let v)?:
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    case .field(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    case nil: break
    }
    if self.ascending != false {
      try visitor.visitSingularBoolField(value: self.ascending, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_Ordering, rhs: Exocore_Store_Ordering) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.ascending != rhs.ascending {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_OrderingValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderingValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "float"),
    2: .same(proto: "uint64"),
    3: .same(proto: "date"),
    4: .same(proto: "min"),
    5: .same(proto: "max"),
    6: .standard(proto: "operation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {self.value = .float(v)}
      case 2:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {self.value = .uint64(v)}
      case 3:
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .date(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .date(v)}
      case 4:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.value = .min(v)}
      case 5:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.value = .max(v)}
      case 6: try decoder.decodeSingularUInt64Field(value: &self.operationID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.value {
    case .float(let v)?:
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    case .uint64(let v)?:
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    case .date(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .min(let v)?:
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    case .max(let v)?:
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    case nil: break
    }
    if self.operationID != 0 {
      try visitor.visitSingularUInt64Field(value: self.operationID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_OrderingValue, rhs: Exocore_Store_OrderingValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.operationID != rhs.operationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_EntityResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityResults"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entities"),
    2: .standard(proto: "skipped_hash"),
    3: .standard(proto: "estimated_count"),
    4: .standard(proto: "current_page"),
    5: .standard(proto: "next_page"),
    6: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.entities)
      case 2: try decoder.decodeSingularBoolField(value: &self.skippedHash)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.estimatedCount)
      case 4: try decoder.decodeSingularMessageField(value: &self._currentPage)
      case 5: try decoder.decodeSingularMessageField(value: &self._nextPage)
      case 6: try decoder.decodeSingularUInt64Field(value: &self.hash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entities, fieldNumber: 1)
    }
    if self.skippedHash != false {
      try visitor.visitSingularBoolField(value: self.skippedHash, fieldNumber: 2)
    }
    if self.estimatedCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.estimatedCount, fieldNumber: 3)
    }
    if let v = self._currentPage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._nextPage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.hash != 0 {
      try visitor.visitSingularUInt64Field(value: self.hash, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_EntityResults, rhs: Exocore_Store_EntityResults) -> Bool {
    if lhs.entities != rhs.entities {return false}
    if lhs.skippedHash != rhs.skippedHash {return false}
    if lhs.estimatedCount != rhs.estimatedCount {return false}
    if lhs._currentPage != rhs._currentPage {return false}
    if lhs._nextPage != rhs._nextPage {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_EntityResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entity"),
    2: .same(proto: "source"),
    3: .standard(proto: "ordering_value"),
    4: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._entity)
      case 2: try decoder.decodeSingularEnumField(value: &self.source)
      case 3: try decoder.decodeSingularMessageField(value: &self._orderingValue)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.hash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._entity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 2)
    }
    if let v = self._orderingValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.hash != 0 {
      try visitor.visitSingularUInt64Field(value: self.hash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_EntityResult, rhs: Exocore_Store_EntityResult) -> Bool {
    if lhs._entity != rhs._entity {return false}
    if lhs.source != rhs.source {return false}
    if lhs._orderingValue != rhs._orderingValue {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
