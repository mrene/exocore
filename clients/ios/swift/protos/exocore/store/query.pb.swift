// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: exocore/store/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Exocore_Store_EntityResultSource: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case pending // = 1
  case chain // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .pending
    case 2: self = .chain
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .pending: return 1
    case .chain: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Exocore_Store_EntityResultSource: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Exocore_Store_EntityResultSource] = [
    .unknown,
    .pending,
    .chain,
  ]
}

#endif  // swift(>=4.2)

public struct Exocore_Store_EntityQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var predicate: OneOf_Predicate? {
    get {return _storage._predicate}
    set {_uniqueStorage()._predicate = newValue}
  }

  public var match: Exocore_Store_MatchPredicate {
    get {
      if case .match(let v)? = _storage._predicate {return v}
      return Exocore_Store_MatchPredicate()
    }
    set {_uniqueStorage()._predicate = .match(newValue)}
  }

  public var trait: Exocore_Store_TraitPredicate {
    get {
      if case .trait(let v)? = _storage._predicate {return v}
      return Exocore_Store_TraitPredicate()
    }
    set {_uniqueStorage()._predicate = .trait(newValue)}
  }

  public var ids: Exocore_Store_IdsPredicate {
    get {
      if case .ids(let v)? = _storage._predicate {return v}
      return Exocore_Store_IdsPredicate()
    }
    set {_uniqueStorage()._predicate = .ids(newValue)}
  }

  public var reference: Exocore_Store_ReferencePredicate {
    get {
      if case .reference(let v)? = _storage._predicate {return v}
      return Exocore_Store_ReferencePredicate()
    }
    set {_uniqueStorage()._predicate = .reference(newValue)}
  }

  public var operations: Exocore_Store_OperationsPredicate {
    get {
      if case .operations(let v)? = _storage._predicate {return v}
      return Exocore_Store_OperationsPredicate()
    }
    set {_uniqueStorage()._predicate = .operations(newValue)}
  }

  public var all: Exocore_Store_AllPredicate {
    get {
      if case .all(let v)? = _storage._predicate {return v}
      return Exocore_Store_AllPredicate()
    }
    set {_uniqueStorage()._predicate = .all(newValue)}
  }

  public var test: Exocore_Store_TestPredicate {
    get {
      if case .test(let v)? = _storage._predicate {return v}
      return Exocore_Store_TestPredicate()
    }
    set {_uniqueStorage()._predicate = .test(newValue)}
  }

  //// Optional projections on traits and fields to be returned.
  public var projections: [Exocore_Store_Projection] {
    get {return _storage._projections}
    set {_uniqueStorage()._projections = newValue}
  }

  //// Query paging requested.
  public var paging: Exocore_Store_Paging {
    get {return _storage._paging ?? Exocore_Store_Paging()}
    set {_uniqueStorage()._paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return _storage._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {_uniqueStorage()._paging = nil}

  //// Query ordering.
  public var ordering: Exocore_Store_Ordering {
    get {return _storage._ordering ?? Exocore_Store_Ordering()}
    set {_uniqueStorage()._ordering = newValue}
  }
  /// Returns true if `ordering` has been explicitly set.
  public var hasOrdering: Bool {return _storage._ordering != nil}
  /// Clears the value of `ordering`. Subsequent reads from it will return its default value.
  public mutating func clearOrdering() {_uniqueStorage()._ordering = nil}

  //// Optional watch token if this query is to be used for watching.
  public var watchToken: UInt64 {
    get {return _storage._watchToken}
    set {_uniqueStorage()._watchToken = newValue}
  }

  //// If specified, if results from server matches this hash, results will be empty with the 
  //// `skipped_hash` field set to `true`.
  public var resultHash: UInt64 {
    get {return _storage._resultHash}
    set {_uniqueStorage()._resultHash = newValue}
  }

  //// Include deleted mutations matches. Can be used to return recently modified entities that
  //// also include deletions. Deleted traits will be included in the results, but will have a 
  //// `deletion_date` field with the date of the deletion.
  public var includeDeleted: Bool {
    get {return _storage._includeDeleted}
    set {_uniqueStorage()._includeDeleted = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Predicate: Equatable {
    case match(Exocore_Store_MatchPredicate)
    case trait(Exocore_Store_TraitPredicate)
    case ids(Exocore_Store_IdsPredicate)
    case reference(Exocore_Store_ReferencePredicate)
    case operations(Exocore_Store_OperationsPredicate)
    case all(Exocore_Store_AllPredicate)
    case test(Exocore_Store_TestPredicate)

  #if !swift(>=4.1)
    public static func ==(lhs: Exocore_Store_EntityQuery.OneOf_Predicate, rhs: Exocore_Store_EntityQuery.OneOf_Predicate) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.match, .match): return {
        guard case .match(let l) = lhs, case .match(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trait, .trait): return {
        guard case .trait(let l) = lhs, case .trait(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ids, .ids): return {
        guard case .ids(let l) = lhs, case .ids(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reference, .reference): return {
        guard case .reference(let l) = lhs, case .reference(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.operations, .operations): return {
        guard case .operations(let l) = lhs, case .operations(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.all, .all): return {
        guard case .all(let l) = lhs, case .all(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.test, .test): return {
        guard case .test(let l) = lhs, case .test(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Exocore_Store_Projection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// If specified, a prefix match will be done against traits' Protobuf full name (`some.package.Name`).
  //// If ends with a dollar sign "$", an exact match is required (ex: `some.package.Name$` will only match this message)
  public var package: [String] = []

  //// Skips the trait if the projection matches.
  public var skip: Bool = false

  //// If specified, only return these fields.
  public var fieldIds: [UInt32] = []

  //// If specified, only return fields annotated with `options.proto`.`field_group_id` matching ids.
  public var fieldGroupIds: [UInt32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Query entities by text match on all indexed fields across all traits.
public struct Exocore_Store_MatchPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var query: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Query entities by IDs.
public struct Exocore_Store_IdsPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Query entities by mutations' operation ids.
//// Used to return entities on which mutations with these operation ids were applied and indexed.
public struct Exocore_Store_OperationsPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var operationIds: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Query all entities.
public struct Exocore_Store_AllPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Used for tests.
public struct Exocore_Store_TestPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Query entities that have a specified trait and optionally matching a trait query.
public struct Exocore_Store_TraitPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var traitName: String = String()

  public var query: Exocore_Store_TraitQuery {
    get {return _query ?? Exocore_Store_TraitQuery()}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  public var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  public mutating func clearQuery() {self._query = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _query: Exocore_Store_TraitQuery? = nil
}

public struct Exocore_Store_TraitQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var predicate: Exocore_Store_TraitQuery.OneOf_Predicate? = nil

  public var match: Exocore_Store_MatchPredicate {
    get {
      if case .match(let v)? = predicate {return v}
      return Exocore_Store_MatchPredicate()
    }
    set {predicate = .match(newValue)}
  }

  public var field: Exocore_Store_TraitFieldPredicate {
    get {
      if case .field(let v)? = predicate {return v}
      return Exocore_Store_TraitFieldPredicate()
    }
    set {predicate = .field(newValue)}
  }

  public var reference: Exocore_Store_TraitFieldReferencePredicate {
    get {
      if case .reference(let v)? = predicate {return v}
      return Exocore_Store_TraitFieldReferencePredicate()
    }
    set {predicate = .reference(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Predicate: Equatable {
    case match(Exocore_Store_MatchPredicate)
    case field(Exocore_Store_TraitFieldPredicate)
    case reference(Exocore_Store_TraitFieldReferencePredicate)

  #if !swift(>=4.1)
    public static func ==(lhs: Exocore_Store_TraitQuery.OneOf_Predicate, rhs: Exocore_Store_TraitQuery.OneOf_Predicate) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.match, .match): return {
        guard case .match(let l) = lhs, case .match(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.field, .field): return {
        guard case .field(let l) = lhs, case .field(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reference, .reference): return {
        guard case .reference(let l) = lhs, case .reference(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Exocore_Store_TraitFieldPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: String = String()

  public var value: Exocore_Store_TraitFieldPredicate.OneOf_Value? = nil

  public var string: String {
    get {
      if case .string(let v)? = value {return v}
      return String()
    }
    set {value = .string(newValue)}
  }

  public var int64: Int64 {
    get {
      if case .int64(let v)? = value {return v}
      return 0
    }
    set {value = .int64(newValue)}
  }

  public var uint64: UInt64 {
    get {
      if case .uint64(let v)? = value {return v}
      return 0
    }
    set {value = .uint64(newValue)}
  }

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .date(let v)? = value {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {value = .date(newValue)}
  }

  public var `operator`: Exocore_Store_TraitFieldPredicate.Operator = .equal

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case string(String)
    case int64(Int64)
    case uint64(UInt64)
    case date(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Exocore_Store_TraitFieldPredicate.OneOf_Value, rhs: Exocore_Store_TraitFieldPredicate.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.string, .string): return {
        guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.int64, .int64): return {
        guard case .int64(let l) = lhs, case .int64(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uint64, .uint64): return {
        guard case .uint64(let l) = lhs, case .uint64(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.date, .date): return {
        guard case .date(let l) = lhs, case .date(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Operator: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case equal // = 0
    case gt // = 1
    case gte // = 2
    case lt // = 3
    case lte // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .equal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .equal
      case 1: self = .gt
      case 2: self = .gte
      case 3: self = .lt
      case 4: self = .lte
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .equal: return 0
      case .gt: return 1
      case .gte: return 2
      case .lt: return 3
      case .lte: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Exocore_Store_TraitFieldPredicate.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Exocore_Store_TraitFieldPredicate.Operator] = [
    .equal,
    .gt,
    .gte,
    .lt,
    .lte,
  ]
}

#endif  // swift(>=4.2)

public struct Exocore_Store_TraitFieldReferencePredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: String = String()

  public var reference: Exocore_Store_ReferencePredicate {
    get {return _reference ?? Exocore_Store_ReferencePredicate()}
    set {_reference = newValue}
  }
  /// Returns true if `reference` has been explicitly set.
  public var hasReference: Bool {return self._reference != nil}
  /// Clears the value of `reference`. Subsequent reads from it will return its default value.
  public mutating func clearReference() {self._reference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _reference: Exocore_Store_ReferencePredicate? = nil
}

public struct Exocore_Store_ReferencePredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Entity id the reference points to
  public var entityID: String = String()

  /// Optional trait id the reference points to
  public var traitID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Exocore_Store_Paging {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Returns results after this given ordering value.
  public var afterOrderingValue: Exocore_Store_OrderingValue {
    get {return _afterOrderingValue ?? Exocore_Store_OrderingValue()}
    set {_afterOrderingValue = newValue}
  }
  /// Returns true if `afterOrderingValue` has been explicitly set.
  public var hasAfterOrderingValue: Bool {return self._afterOrderingValue != nil}
  /// Clears the value of `afterOrderingValue`. Subsequent reads from it will return its default value.
  public mutating func clearAfterOrderingValue() {self._afterOrderingValue = nil}

  //// Returns results before this given ordering value.
  public var beforeOrderingValue: Exocore_Store_OrderingValue {
    get {return _beforeOrderingValue ?? Exocore_Store_OrderingValue()}
    set {_beforeOrderingValue = newValue}
  }
  /// Returns true if `beforeOrderingValue` has been explicitly set.
  public var hasBeforeOrderingValue: Bool {return self._beforeOrderingValue != nil}
  /// Clears the value of `beforeOrderingValue`. Subsequent reads from it will return its default value.
  public mutating func clearBeforeOrderingValue() {self._beforeOrderingValue = nil}

  //// Desired results count. Default if 0.
  public var count: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _afterOrderingValue: Exocore_Store_OrderingValue? = nil
  fileprivate var _beforeOrderingValue: Exocore_Store_OrderingValue? = nil
}

public struct Exocore_Store_Ordering {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Value by which we want results to be ordered.
  public var value: Exocore_Store_Ordering.OneOf_Value? = nil

  public var score: Bool {
    get {
      if case .score(let v)? = value {return v}
      return false
    }
    set {value = .score(newValue)}
  }

  public var operationID: Bool {
    get {
      if case .operationID(let v)? = value {return v}
      return false
    }
    set {value = .operationID(newValue)}
  }

  public var field: String {
    get {
      if case .field(let v)? = value {return v}
      return String()
    }
    set {value = .field(newValue)}
  }

  //// Direction of ordering.
  public var ascending: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// Value by which we want results to be ordered.
  public enum OneOf_Value: Equatable {
    case score(Bool)
    case operationID(Bool)
    case field(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Exocore_Store_Ordering.OneOf_Value, rhs: Exocore_Store_Ordering.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.score, .score): return {
        guard case .score(let l) = lhs, case .score(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.operationID, .operationID): return {
        guard case .operationID(let l) = lhs, case .operationID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.field, .field): return {
        guard case .field(let l) = lhs, case .field(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Exocore_Store_OrderingValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Primary comparison
  public var value: Exocore_Store_OrderingValue.OneOf_Value? = nil

  public var float: Float {
    get {
      if case .float(let v)? = value {return v}
      return 0
    }
    set {value = .float(newValue)}
  }

  public var uint64: UInt64 {
    get {
      if case .uint64(let v)? = value {return v}
      return 0
    }
    set {value = .uint64(newValue)}
  }

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .date(let v)? = value {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {value = .date(newValue)}
  }

  public var min: Bool {
    get {
      if case .min(let v)? = value {return v}
      return false
    }
    set {value = .min(newValue)}
  }

  public var max: Bool {
    get {
      if case .max(let v)? = value {return v}
      return false
    }
    set {value = .max(newValue)}
  }

  //// Secondary comparison, in case values were equal. In this case,
  //// the last operation id that mutated the entity is used.
  public var operationID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  //// Primary comparison
  public enum OneOf_Value: Equatable {
    case float(Float)
    case uint64(UInt64)
    case date(SwiftProtobuf.Google_Protobuf_Timestamp)
    case min(Bool)
    case max(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Exocore_Store_OrderingValue.OneOf_Value, rhs: Exocore_Store_OrderingValue.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.float, .float): return {
        guard case .float(let l) = lhs, case .float(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uint64, .uint64): return {
        guard case .uint64(let l) = lhs, case .uint64(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.date, .date): return {
        guard case .date(let l) = lhs, case .date(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.min, .min): return {
        guard case .min(let l) = lhs, case .min(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.max, .max): return {
        guard case .max(let l) = lhs, case .max(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Exocore_Store_EntityResults {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Entities matching query.
  public var entities: [Exocore_Store_EntityResult] {
    get {return _storage._entities}
    set {_uniqueStorage()._entities = newValue}
  }

  //// If query specified a `result_hash`, this is set to `true` if the results
  //// had the same hash has the specified and that `entities` were set to empty.
  public var skippedHash: Bool {
    get {return _storage._skippedHash}
    set {_uniqueStorage()._skippedHash = newValue}
  }

  //// Estimated number of entities matching, based on number of matching mutations.
  public var estimatedCount: UInt32 {
    get {return _storage._estimatedCount}
    set {_uniqueStorage()._estimatedCount = newValue}
  }

  //// Paging token of the current results.
  public var currentPage: Exocore_Store_Paging {
    get {return _storage._currentPage ?? Exocore_Store_Paging()}
    set {_uniqueStorage()._currentPage = newValue}
  }
  /// Returns true if `currentPage` has been explicitly set.
  public var hasCurrentPage: Bool {return _storage._currentPage != nil}
  /// Clears the value of `currentPage`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentPage() {_uniqueStorage()._currentPage = nil}

  //// Paging token of the next page of results.
  public var nextPage: Exocore_Store_Paging {
    get {return _storage._nextPage ?? Exocore_Store_Paging()}
    set {_uniqueStorage()._nextPage = newValue}
  }
  /// Returns true if `nextPage` has been explicitly set.
  public var hasNextPage: Bool {return _storage._nextPage != nil}
  /// Clears the value of `nextPage`. Subsequent reads from it will return its default value.
  public mutating func clearNextPage() {_uniqueStorage()._nextPage = nil}

  //// Hash of the results. Can be used to prevent receiving same results if they haven't
  //// changed by using the `result_hash` field on the query.
  public var hash: UInt64 {
    get {return _storage._hash}
    set {_uniqueStorage()._hash = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Exocore_Store_EntityResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The entity with its traits. Projection could have been done on the entity, which will
  //// be indicated in its traits' details field.
  public var entity: Exocore_Store_Entity {
    get {return _entity ?? Exocore_Store_Entity()}
    set {_entity = newValue}
  }
  /// Returns true if `entity` has been explicitly set.
  public var hasEntity: Bool {return self._entity != nil}
  /// Clears the value of `entity`. Subsequent reads from it will return its default value.
  public mutating func clearEntity() {self._entity = nil}

  //// Indicates where the entity was taken from in terms of storage. If all of the entities'
  //// traits were coming from the chain (i.e. committed), the source will be `CHAIN`. Otherwise,
  //// as soon as one entity mutation is coming from pending store (i.e. not committed yet), this
  //// field will be `PENDING`.
  ////
  //// This can be used to know if an entity can be considered stable once mutations were executed on it.
  //// Once it's committed, a majority of nodes agreed on it and will not result in further changes happening
  //// before the latest consistent timestamp.
  public var source: Exocore_Store_EntityResultSource = .unknown

  //// Value to be used to order results. `EntityResults` already contains ordered results,
  //// but it may be useful to compare ordering queries (ex.: to merge different pages)
  public var orderingValue: Exocore_Store_OrderingValue {
    get {return _orderingValue ?? Exocore_Store_OrderingValue()}
    set {_orderingValue = newValue}
  }
  /// Returns true if `orderingValue` has been explicitly set.
  public var hasOrderingValue: Bool {return self._orderingValue != nil}
  /// Clears the value of `orderingValue`. Subsequent reads from it will return its default value.
  public mutating func clearOrderingValue() {self._orderingValue = nil}

  //// Hash of the tntiy result. Can be used to compare if the entity has changed since last results.
  public var hash: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _entity: Exocore_Store_Entity? = nil
  fileprivate var _orderingValue: Exocore_Store_OrderingValue? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "exocore.store"

extension Exocore_Store_EntityResultSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "CHAIN"),
  ]
}

extension Exocore_Store_EntityQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "match"),
    2: .same(proto: "trait"),
    3: .same(proto: "ids"),
    4: .same(proto: "reference"),
    10: .same(proto: "operations"),
    11: .same(proto: "all"),
    99: .same(proto: "test"),
    7: .same(proto: "projections"),
    5: .same(proto: "paging"),
    6: .same(proto: "ordering"),
    8: .standard(proto: "watch_token"),
    9: .standard(proto: "result_hash"),
    12: .standard(proto: "include_deleted"),
  ]

  fileprivate class _StorageClass {
    var _predicate: Exocore_Store_EntityQuery.OneOf_Predicate?
    var _projections: [Exocore_Store_Projection] = []
    var _paging: Exocore_Store_Paging? = nil
    var _ordering: Exocore_Store_Ordering? = nil
    var _watchToken: UInt64 = 0
    var _resultHash: UInt64 = 0
    var _includeDeleted: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _predicate = source._predicate
      _projections = source._projections
      _paging = source._paging
      _ordering = source._ordering
      _watchToken = source._watchToken
      _resultHash = source._resultHash
      _includeDeleted = source._includeDeleted
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Exocore_Store_MatchPredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .match(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .match(v)}
        }()
        case 2: try {
          var v: Exocore_Store_TraitPredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .trait(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .trait(v)}
        }()
        case 3: try {
          var v: Exocore_Store_IdsPredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .ids(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .ids(v)}
        }()
        case 4: try {
          var v: Exocore_Store_ReferencePredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .reference(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .reference(v)}
        }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._paging) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._ordering) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._projections) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._watchToken) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._resultHash) }()
        case 10: try {
          var v: Exocore_Store_OperationsPredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .operations(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .operations(v)}
        }()
        case 11: try {
          var v: Exocore_Store_AllPredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .all(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .all(v)}
        }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._includeDeleted) }()
        case 99: try {
          var v: Exocore_Store_TestPredicate?
          if let current = _storage._predicate {
            try decoder.handleConflictingOneOf()
            if case .test(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._predicate = .test(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._predicate {
      case .match?: try {
        guard case .match(let v)? = _storage._predicate else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .trait?: try {
        guard case .trait(let v)? = _storage._predicate else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .ids?: try {
        guard case .ids(let v)? = _storage._predicate else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .reference?: try {
        guard case .reference(let v)? = _storage._predicate else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      default: break
      }
      if let v = _storage._paging {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._ordering {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._projections.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._projections, fieldNumber: 7)
      }
      if _storage._watchToken != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._watchToken, fieldNumber: 8)
      }
      if _storage._resultHash != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._resultHash, fieldNumber: 9)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._predicate {
      case .operations?: try {
        guard case .operations(let v)? = _storage._predicate else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .all?: try {
        guard case .all(let v)? = _storage._predicate else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      default: break
      }
      if _storage._includeDeleted != false {
        try visitor.visitSingularBoolField(value: _storage._includeDeleted, fieldNumber: 12)
      }
      if case .test(let v)? = _storage._predicate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_EntityQuery, rhs: Exocore_Store_EntityQuery) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._predicate != rhs_storage._predicate {return false}
        if _storage._projections != rhs_storage._projections {return false}
        if _storage._paging != rhs_storage._paging {return false}
        if _storage._ordering != rhs_storage._ordering {return false}
        if _storage._watchToken != rhs_storage._watchToken {return false}
        if _storage._resultHash != rhs_storage._resultHash {return false}
        if _storage._includeDeleted != rhs_storage._includeDeleted {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_Projection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Projection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "package"),
    2: .same(proto: "skip"),
    4: .standard(proto: "field_ids"),
    5: .standard(proto: "field_group_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.package) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.skip) }()
      case 4: try { try decoder.decodeRepeatedUInt32Field(value: &self.fieldIds) }()
      case 5: try { try decoder.decodeRepeatedUInt32Field(value: &self.fieldGroupIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.package.isEmpty {
      try visitor.visitRepeatedStringField(value: self.package, fieldNumber: 1)
    }
    if self.skip != false {
      try visitor.visitSingularBoolField(value: self.skip, fieldNumber: 2)
    }
    if !self.fieldIds.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.fieldIds, fieldNumber: 4)
    }
    if !self.fieldGroupIds.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.fieldGroupIds, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_Projection, rhs: Exocore_Store_Projection) -> Bool {
    if lhs.package != rhs.package {return false}
    if lhs.skip != rhs.skip {return false}
    if lhs.fieldIds != rhs.fieldIds {return false}
    if lhs.fieldGroupIds != rhs.fieldGroupIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_MatchPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_MatchPredicate, rhs: Exocore_Store_MatchPredicate) -> Bool {
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_IdsPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdsPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_IdsPredicate, rhs: Exocore_Store_IdsPredicate) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_OperationsPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationsPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "operation_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.operationIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operationIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.operationIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_OperationsPredicate, rhs: Exocore_Store_OperationsPredicate) -> Bool {
    if lhs.operationIds != rhs.operationIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_AllPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AllPredicate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_AllPredicate, rhs: Exocore_Store_AllPredicate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_TestPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_TestPredicate, rhs: Exocore_Store_TestPredicate) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_TraitPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraitPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trait_name"),
    2: .same(proto: "query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.traitName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.traitName.isEmpty {
      try visitor.visitSingularStringField(value: self.traitName, fieldNumber: 1)
    }
    if let v = self._query {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_TraitPredicate, rhs: Exocore_Store_TraitPredicate) -> Bool {
    if lhs.traitName != rhs.traitName {return false}
    if lhs._query != rhs._query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_TraitQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraitQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "match"),
    2: .same(proto: "field"),
    3: .same(proto: "reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Exocore_Store_MatchPredicate?
        if let current = self.predicate {
          try decoder.handleConflictingOneOf()
          if case .match(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.predicate = .match(v)}
      }()
      case 2: try {
        var v: Exocore_Store_TraitFieldPredicate?
        if let current = self.predicate {
          try decoder.handleConflictingOneOf()
          if case .field(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.predicate = .field(v)}
      }()
      case 3: try {
        var v: Exocore_Store_TraitFieldReferencePredicate?
        if let current = self.predicate {
          try decoder.handleConflictingOneOf()
          if case .reference(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.predicate = .reference(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.predicate {
    case .match?: try {
      guard case .match(let v)? = self.predicate else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .field?: try {
      guard case .field(let v)? = self.predicate else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .reference?: try {
      guard case .reference(let v)? = self.predicate else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_TraitQuery, rhs: Exocore_Store_TraitQuery) -> Bool {
    if lhs.predicate != rhs.predicate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_TraitFieldPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraitFieldPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "string"),
    3: .same(proto: "int64"),
    4: .same(proto: "uint64"),
    5: .same(proto: "date"),
    6: .same(proto: "operator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.field) }()
      case 2: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .string(v)}
      }()
      case 3: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.value = .int64(v)}
      }()
      case 4: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {self.value = .uint64(v)}
      }()
      case 5: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .date(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .date(v)}
      }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.`operator`) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.field.isEmpty {
      try visitor.visitSingularStringField(value: self.field, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .string?: try {
      guard case .string(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .int64?: try {
      guard case .int64(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case .uint64?: try {
      guard case .uint64(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }()
    case .date?: try {
      guard case .date(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if self.`operator` != .equal {
      try visitor.visitSingularEnumField(value: self.`operator`, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_TraitFieldPredicate, rhs: Exocore_Store_TraitFieldPredicate) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.value != rhs.value {return false}
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_TraitFieldPredicate.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EQUAL"),
    1: .same(proto: "GT"),
    2: .same(proto: "GTE"),
    3: .same(proto: "LT"),
    4: .same(proto: "LTE"),
  ]
}

extension Exocore_Store_TraitFieldReferencePredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraitFieldReferencePredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "reference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.field) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._reference) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.field.isEmpty {
      try visitor.visitSingularStringField(value: self.field, fieldNumber: 1)
    }
    if let v = self._reference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_TraitFieldReferencePredicate, rhs: Exocore_Store_TraitFieldReferencePredicate) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs._reference != rhs._reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_ReferencePredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReferencePredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
    2: .standard(proto: "trait_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entityID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.traitID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entityID.isEmpty {
      try visitor.visitSingularStringField(value: self.entityID, fieldNumber: 1)
    }
    if !self.traitID.isEmpty {
      try visitor.visitSingularStringField(value: self.traitID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_ReferencePredicate, rhs: Exocore_Store_ReferencePredicate) -> Bool {
    if lhs.entityID != rhs.entityID {return false}
    if lhs.traitID != rhs.traitID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_Paging: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Paging"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "after_ordering_value"),
    2: .standard(proto: "before_ordering_value"),
    3: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._afterOrderingValue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._beforeOrderingValue) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._afterOrderingValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._beforeOrderingValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt32Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_Paging, rhs: Exocore_Store_Paging) -> Bool {
    if lhs._afterOrderingValue != rhs._afterOrderingValue {return false}
    if lhs._beforeOrderingValue != rhs._beforeOrderingValue {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_Ordering: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ordering"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .standard(proto: "operation_id"),
    3: .same(proto: "field"),
    4: .same(proto: "ascending"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.value = .score(v)}
      }()
      case 2: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.value = .operationID(v)}
      }()
      case 3: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .field(v)}
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.ascending) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .score?: try {
      guard case .score(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .operationID?: try {
      guard case .operationID(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .field?: try {
      guard case .field(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.ascending != false {
      try visitor.visitSingularBoolField(value: self.ascending, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_Ordering, rhs: Exocore_Store_Ordering) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.ascending != rhs.ascending {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_OrderingValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderingValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "float"),
    2: .same(proto: "uint64"),
    3: .same(proto: "date"),
    4: .same(proto: "min"),
    5: .same(proto: "max"),
    6: .standard(proto: "operation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {self.value = .float(v)}
      }()
      case 2: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {self.value = .uint64(v)}
      }()
      case 3: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .date(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .date(v)}
      }()
      case 4: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.value = .min(v)}
      }()
      case 5: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.value = .max(v)}
      }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.operationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .float?: try {
      guard case .float(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    }()
    case .uint64?: try {
      guard case .uint64(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case .date?: try {
      guard case .date(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .min?: try {
      guard case .min(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case .max?: try {
      guard case .max(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if self.operationID != 0 {
      try visitor.visitSingularUInt64Field(value: self.operationID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_OrderingValue, rhs: Exocore_Store_OrderingValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.operationID != rhs.operationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_EntityResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityResults"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entities"),
    2: .standard(proto: "skipped_hash"),
    3: .standard(proto: "estimated_count"),
    4: .standard(proto: "current_page"),
    5: .standard(proto: "next_page"),
    6: .same(proto: "hash"),
  ]

  fileprivate class _StorageClass {
    var _entities: [Exocore_Store_EntityResult] = []
    var _skippedHash: Bool = false
    var _estimatedCount: UInt32 = 0
    var _currentPage: Exocore_Store_Paging? = nil
    var _nextPage: Exocore_Store_Paging? = nil
    var _hash: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _entities = source._entities
      _skippedHash = source._skippedHash
      _estimatedCount = source._estimatedCount
      _currentPage = source._currentPage
      _nextPage = source._nextPage
      _hash = source._hash
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._entities) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._skippedHash) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._estimatedCount) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._currentPage) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._nextPage) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._hash) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._entities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._entities, fieldNumber: 1)
      }
      if _storage._skippedHash != false {
        try visitor.visitSingularBoolField(value: _storage._skippedHash, fieldNumber: 2)
      }
      if _storage._estimatedCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._estimatedCount, fieldNumber: 3)
      }
      if let v = _storage._currentPage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._nextPage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._hash != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._hash, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_EntityResults, rhs: Exocore_Store_EntityResults) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._entities != rhs_storage._entities {return false}
        if _storage._skippedHash != rhs_storage._skippedHash {return false}
        if _storage._estimatedCount != rhs_storage._estimatedCount {return false}
        if _storage._currentPage != rhs_storage._currentPage {return false}
        if _storage._nextPage != rhs_storage._nextPage {return false}
        if _storage._hash != rhs_storage._hash {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Exocore_Store_EntityResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entity"),
    2: .same(proto: "source"),
    3: .standard(proto: "ordering_value"),
    4: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entity) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._orderingValue) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._entity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.source != .unknown {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 2)
    }
    if let v = self._orderingValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.hash != 0 {
      try visitor.visitSingularUInt64Field(value: self.hash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Exocore_Store_EntityResult, rhs: Exocore_Store_EntityResult) -> Bool {
    if lhs._entity != rhs._entity {return false}
    if lhs.source != rhs.source {return false}
    if lhs._orderingValue != rhs._orderingValue {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
